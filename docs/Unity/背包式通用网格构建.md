---
sidebar_position: 4
---
# 背包式通用网格构建

实际完成是一个通用背包系统，提供如下功能

- 网格容量系统，同塔科夫，生化危机；
- 可选的加入容量指标，类似**负重**，同绝地求生；
- 可选的堆叠，底层实现为最大堆叠容量与当前容量；
- 预览状态(未放置)，物品背包形态，物品实际形态分离，可选不同模型，也可相同；
- 背包内物品可以与其实例相同，可以有其独立逻辑(即可以像防御塔，有其特定逻辑)；
- 通用系统，实际存储为泛型`GridObject`,可用作塔防框架，即时战略框架，亦或者模拟经营框架；
- 封装两层泛型，提供完善的自定义操作；

## 底层框架构建
>搭建泛型底层，提供核心操作；
```cs
// 泛型，满足扩展需求;
public class GridXY<TGridObject>
{
	// 定义基本信息大小
	private int width;  
	private int height;  
	private float cellSize;  
	private Vector3 originPosition;  
	private TGridObject[,] gridArray;
	
	// 背包内容管理器，提供物品查询支持
	private Dictionary<string, int> Bag;

	public GridXY(******)
	{
		// 初始化背包
	}

	// 提供基础操作
	public int GetWidth() 
	{  
	    return width;  
	}  
	public int GetHeight() 
	{  
	    return height;  
	}
	//.......
	
	// 提供底层核心操作
	// 设置物品
	public void SetGridObject(int x, int y, TGridObject value) 
	{  
	    if (x >= 0 && y >= 0 && x < width && y < height) 
	    {  
	        gridArray[x, y] = value;
	    }
    }
    // 获取物品
    public TGridObject GetGridObject(int x, int y) 
    {  
	    if (x >= 0 && y >= 0 && x < width && y < height) 
	    {  
	        return gridArray[x, y];  
	    } 
	    else 
	    {  
	        return default(TGridObject);  
	    }
    }
    // 取出物品
    public int OutObjectCount(String name, int number)  
	{  
	    if (Bag.ContainsKey(name))  
	    {        
		    int tem = Bag[name];  
	        if (tem > number)  
	        {            
		        Bag[name] -= number;  
	            return number;  
	        }        
		    Bag.Remove(name);  
	        return tem;  
	    }    
	    return 0;  
	}
	// 放入物品
	public void InObjectCount(String name, int number)  
	{  
	    if (Bag.ContainsKey(name))  
	    {        
		    Bag[name] += number;  
	        Debug.LogWarning(name + "还有" + Bag[name]);  
	        return;  
	    }    
	    Bag.Add(name, number);  
	}
	
}
```

## 物品泛型的实现

>具体物品的实现，也可认为是其他物品想进入背包的父类；

```cs
public class PlacedObjectTypeSO : ScriptableObject
{
	public string nameString;  
	
	// 分别为背包外实例，背包内实例，预览放置实例;
	// 解决部分模型过于精细或背包过大造成的卡顿;
	public Transform usePrefab;  
	public Transform prefab;  
	public Transform visual;  
	public int width;  
	public int height;  

	public int number;  
	public int maxNumber;  
	  
	public int ID;
	
	//物品的放置位置相关
	public List<Vector2Int> GetGridPositionList(Vector2Int offset, Dir dir){};
	public Vector2Int GetRotationOffset(Dir dir){};
}


public class PlacedObject_Done : MonoBehaviour
{
	// 部分信息
	private Vector2Int origin;  
	private PlacedObjectTypeSO.Dir dir;  

	// 堆叠相关信息
	private bool canStack; // 疑似冗余信息
	private int number = 1;  
	private int maxNumber = 1;
	
	// 创建物品
	public static PlacedObject_Done Create()
	{
		Transform placedObjectTransform = Instantiate(*****){};
		PlacedObject_Done placedObject = placedObjectTransform.GetCom<>();
		// 从SO文件创建
		placedObject.Setup(placedObjectTypeSO, origin, dir);
		
		return placedObject;
	}
	
	// 信息初始化
	private void Setup(****)  
	{  
	
	    this.placedObjectTypeSO = placedObjectTypeSO;  
	    this.origin = origin;  
	    this.dir = dir;  
	  
	    // 堆叠内容  
	    this.number = placedObjectTypeSO.number;  
	    this.maxNumber = placedObjectTypeSO.maxNumber;  
	  
	    if (maxNumber != number)  
	    {        
		    canStack = true;  
	    }
	}
	
	// 物品的核心信息
	// 根据选择判断占地信息;
	public List<Vector2Int> GetGridPositionList() 
	{  
	    return placedObjectTypeSO.GetGridPositionList(origin, dir);  
	}

	// 物品的特定操作
	// 堆叠，且尝试返回剩余值
	public int Stack(int number)  
	{  
	    this.number += number;  
	    Debug.Log(this.number);  
	    if (this.number > maxNumber)  
	    {        
		    int temp = this.number - maxNumber;  
	        this.number = maxNumber;  
	        return temp;  
	    }    
		    return 0;  
	}
	// 设置数值等
	public int GetNumber()  
	{  
	    return number;  
	}  
	public void SetNumber(int number)  
	{  
	    this.number = number;  
	}
}
```




## 核心控制层实现
>用于控制`Grid`底层网格的系统，提供通用操作；
>共有两部分，
```cs

public class GridSystemXY : MonoBehaviour
{
	// 具体放置的类型，如不习惯，可以解耦独立。
	public class GridObject
	{
		private GridXY<GridObject> grid;  
		private int x;  
		private int y;  
		public PlacedObject_Done placedObject;  

		// 物品构建时，物品持有当前所在背包的引用;
		public GridObject(GridXY<GridObject> grid, int x, int y) 
		{  
		    this.grid = grid;  
		    this.x = x;  
		    this.y = y;  
		    placedObject = null;  
		}
		// 提供配套的操作
		public void SetPlacedObject(PlacedObject_Done placedObject) 
		{  
		    this.placedObject = placedObject;  
		}
		public bool CanBuild(PlacedObjectTypeSO placedObjectTypeSO){};
		public bool CanStack(PlacedObjectTypeSO placedObjectTypeSO){};
		public int Stack(){};
		
	}

	public static GridSystemXY Instance { get; private set; }

	// 背包管理器，应对多个背包;
	public Dictionary<int, GridXY<GridSystemXY.GridObject>> gridDictionary;
	
	// 当前操作的背包
	private GridXY<GridObject> grid;
	
	// 当前操作的物品
	private PlacedObjectTypeSO.Dir dir; 
	private PlacedObjectTypeSO placedObjectTypeSO;

	// 移动位置时的逻辑。  
	private bool isSwitchingMode = false;  
	private List<Vector2Int> tempGridPositionList = null;
	
	// 备份数据  
	private int number;

	// 初始化
	private void Awake() 
	{  
	    Instance = this;  
	  
	    gridDictionary = new Dictionary<int, GridXY<GridSystemXY.GridObject>>();  
	    int gridWidth = 3;  
	    int gridHeight = 4;  
	    float cellSize = 10f;  
	    AddGrid(1, grid);  
	    AddGrid(2, grid);  
	  
	    placedObjectTypeSO = null;  
	}

	// 部分系统
	// 放置系统
	private void Build()
	{
		foreach(var ID in gridDictionary)
		{
			//获取鼠标位置，查看是否可以放置
		}
		if (canBuild)
		{
			// 堆叠放置
			if(canStack)
			{
				int tem = targetGridObject.Stack(number);
				if(tem > 0)
				{
					//未完全放置，仅更新当前数量
					return;
				}
			}
			
			// 放置
			{
				// 指定位置创建物品
				placedObject = PlacedObject_Done.Create(****);
			}
			
			// 松开;
			DeselectObjectType();
		}
	}

}


```