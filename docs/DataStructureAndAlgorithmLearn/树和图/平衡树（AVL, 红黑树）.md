# 平衡树（AVL, 红黑树）

红黑树也是一种自平衡二叉查找树，它与AVL树类似，都在添加和删除的时候通过旋转操作保持二叉树的平衡，以求更高效的查询性能。

与AVL树相比，红黑树牺牲了部分平衡性，以换取插入/删除操作时**较少的旋转**操作，整体来说性能要优于AVL树。

虽然RBTree是复杂的, 但它的**最坏情况运行时间**也是非常良好的,并且在实践中是高效的：

> 它可以在**O(log n)**时间内做查找,插入和删除,这里的**n 是树中元素的数目.**

### 红黑树原则

- 特性1：节点非黑即红
    
- 特性2：根节点一定是黑色
    
- 特性3：叶子节点（NIL）一定是黑色
    
- 特性4：每个红色节点的两个子节点都为黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
    
- 特性5：从任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点。
    

### 红黑树操作

**默认新插入的节点为红色：**

因为父节点为黑色的概率较大，插入新节点为红色，可以避免颜色冲突

1. 父节点为黑；
    
2. 父节点为红且“叔”节点为红；且为左儿子；
    
3. 父节点为红且“叔”节点为黑；且为左儿子；
    

对于1，直接插入不影响平衡，直接插入；

对于2，3，本质是将自身，父节点，爷节点处理，一般为自身与爷节点变红，父节点变黑，然后旋转。

若非左儿子，则先左旋，让其变为左儿子；

对于2，则是将父节点，叔节点变黑，爷节点变红，右旋；

对于3，则是将父节点变黑，爷节点变红，右旋。

对于位于右侧的，对称处理即可，即改为左旋。

## 常见问题

### **问：有了平衡二叉树，为什么还需要红黑树？**

AVL的左右子树高度差不能超过1，每次进行插入/删除操作时，几乎都需要通过旋转操作保持平衡

在频繁进行插入/删除的场景中，频繁的旋转操作使得AVL的性能大打折扣

红黑树通过牺牲严格的平衡，换取插入/删除时少量的旋转操作，

整体性能优于AVL

- 红黑树插入时的不平衡，不超过两次旋转就可以解决；删除时的不平衡，不超过三次旋转就能解决
    
- 红黑树的红黑规则，保证最坏的情况下，也能在O ( log n）时间内完成查找操作。
    

### **红黑树与AVL树区别**

**1、调整平衡的实现机制不同**

红黑树根据路径上黑色节点数目一致，来确定是否失衡，如果失衡，就通过变色和旋转来恢复

AVL根据树的平衡因子(**所有节点的左右子树高度差的绝对值不超过1**)，来确定是否失衡，如果失衡，就通过旋转来恢复

**2、红黑树的插入效率更高**

红黑树是用**非严格的平衡**来换取增删节点时候旋转次数的降低，**任何不平衡都会在三次旋转之内解决**，

红黑树并不追求“完全平衡”，它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能

而AVL是**严格平衡树**(高度平衡的二叉搜索树)，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多。

所以红黑树的插入效率更高

**3、红黑树统计性能比AVL树更高**

红黑树能够以**O(log n)** 的时间复杂度进行查询、插入、删除操作。

AVL树查找、插入和删除在平均和最坏情况下都是**O(log n)**。

红黑树的算法时间复杂度和AVL相同，**但统计性能比AVL树更高**，

**4、适用性：AVL查找效率高**

**如果你的应用中，查询的次数远远大于插入和删除，那么选择AVL树，如果查询和插入删除次数几乎差不多，应选择红黑树**。

即，有时仅为了排序（建立-遍历-删除），不查找或查找次数很少，R-B树合算一些。