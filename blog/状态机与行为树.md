---
slug: StateMachine
title: 状态机与行为树的实现;Behavior Designer的使用与自写状态机的几种方法;
tags:
  - Unity
date: 2024-10-10
keywords:
  - Unity
  - StateMachine
  - Behavior Designer
  - AI
summary: "本博客详细介绍AI的基本概念，以及AI的两种常见设计模式：状态机和行为树。通过实例讲解，帮助开发者更好地理解AI的设计与实现。"
metaDescription: "本博客详细介绍AI的基本概念，以及AI的两种常见设计模式：状态机和行为树。通过实例讲解，帮助开发者更好地理解AI的设计与实现。"
draft: false
---
本文章未完结;
<!--truncate-->
:::warning
本文章未完结;
:::

:::info 提示
以下部分内容将会涉及插件[Behavior Designer](https://assetstore.unity.com/packages/tools/visual-scripting/behavior-designer-behavior-trees-for-everyone-15277)  ；
代码仅为演示所需，并非实际实现代码，非本人所使用代码；
**本文较长，请按需阅读；**
:::



# 状态机与行为树

## 为何写？


笔者在初学的时候并不写状态机，而是写到一块，做一个`if`判断大王，直到写出了下面这个屎上屎的代码：
```cs
public void Refresh()
{
	if (_state != PlayerState.Dead && _state!= PlayerState.Start)
    {
	    OnMove();
	    Jump();
        Fall();
        ToGround();
	}
}
private void OnMove()
{
	//...
	if (moveInput != Vector2.zero)
	{
		_targetSpeed = _input._isRunInput ? _runSpeed : _walkSpeed;
        playerState = _input._isRunInput ? PlayerState.Run : PlayerState.Walk;
        _curSpeed = Mathf.Lerp(_curSpeed, _targetSpeed, Time.deltaTime * 8);
        if (moveInput.x != 0)
        {
			if (moveInput.x > 0)
            {
	            transform.localScale = new Vector3(1, 1, 1);
            }
            else if (moveInput.x < 0)
	        {
			    transform.localScale = new Vector3(-1, 1, 1);
            }
        }
    }
    else
    {
	    playerState = PlayerState.Idle;
	    _curSpeed = Mathf.Lerp(_curSpeed, 0, Time.deltaTime * 10);
	}
	if(!_isAir)
	{
		_state = playerState;
    }
	//...
}

```

这个是GameJame上写的一个`PlayerCon`，完全通过`if`来判断，的确能跑，但是极其不美观，毫无扩展性而言。  
为什么会这样？ 用比较官方的话来说，是因为：
- **缺乏模块化设计**：所有的逻辑都集中在一个方法中，导致代码难以组织和理解。
- **状态管理不清晰**：没有明确的状态管理机制，导致对角色行为的控制变得混乱。
- **可读性差**：混合了多个职责（如移动、跳跃、落地等）的代码让逻辑变得复杂，不利于调试和扩展。

通俗的说，就是：你一个OnMove负责了多少东西啊，能不复杂才怪。
## 应该怎么写？

大概的解决方法就是将各个部分解耦，将一个模块分解为多个模块。例如以下：
- 一个控制类，控制状态的切换；
- 每个状态(Idle,Move,Run)，分别一个类；
- 每个类定义一个各自的Updata，更新各自的行为；

实际上这就是状态机了，在真正写状态机前，先来聊聊行为树；
具体代码示例会在后文给出；

## 区别与分析
首先阐明一个观点，我认为状态机(State Machine)和行为树(Behavior Tree)本质上是一样的。

- 状态机管理多个状态，负责状态的切换；
- 行为树则序列执行各个行为，当满足一定条件后，进行行为的跳转；

通常来说，状态包括此时执行什么动画，刷新那些位置，更关注**当前做什么**；
而行为树，则是当前的完整的行为，不仅包括当前的行为，还有一套完整的决策系统，决定接下来做什么。

简单的说状态机仅仅负责刷新内容，状态切换的判定依赖于外部方法调用状态机。例如下列代码：
```cs
public class PlayerIdlingState : PlayerMovementState  
{  
    GameTimer GameTimer { get; set; }  
    //调用父类的构造函数  
    
    public override void Enter()  
    {
        animator.SetBool(AnimatorID.HasInputID, false);  
  
    }  
    public override void Update()  
    {
        //该状态操作 
    }  
    public override void Exit()    
    {        
		//调整animator 
	}
}
```
但是**如果状态包括当收到什么内容时呼叫状态机切换至什么状态**，那**我**就认为，这个状态机就可以认为是一个**具备部分行为树特征**的状态机，**甚至就是状态机**。例如下列代码：
```cs
public class PlayerIdlingState : PlayerMovementState  
{  
    GameTimer GameTimer { get; set; }  
    //调用父类的构造函数  
    
    public override void Enter()  
    {
        animator.SetBool(AnimatorID.HasInputID, false);  
  
    }  
    public override void Update()  
    {
        //该状态操作 
        Move();
    }  
    public override void Exit()    
    {        
		//调整animator 
	}
	public void Move()
	{
		if(_input.Space == true)
		{
			StateMachine.ChangeState("Jump");
		}
	}
}
```

因而可以看出，行为树是状态机的Pro版，其拥有复杂的AI逻辑和动态决策。相比状态机，更能适应复杂逻辑的设计；
:::warning
切记笔者的一个观点，标准的状态机是不包括决策的！包括决策的状态机，就是一个有着行为树特征的“状态机”。
:::

## 状态机
### 怎么设计？

首先梳理一下框架：
- 我们需要一个状态机管理状态的初始化以及状态的切换；
- 每个状态应该会有独立的行为，也有可能需要进行一些事件的订阅；
- 为了更好的进行状态机的编写，我们会引入部分行为树的特性
	- 每个状态将包含一定的决策，负责状态的切换

实际上相当的简单，以下是示例代码：
```csharp
//状态机内容
public class StateMachine
{
    private IState currentState;
    // 提供状态切换的接口;
    public void ChangeState(IState newState)
    {
        if (currentState != null)
        {
            currentState.Exit();
        }
        currentState = newState;
        
        currentState.Enter();
    }
    public void Update()
    {
        if (currentState != null)
        {
            currentState.Execute();
        }
    }
}

//示例状态
public class MoveState : IState
{
    public override void Enter()
    {
        Debug.Log("Entering Move State");
        animator.Play("Move"); // 播放移动动画
    }
    public override void Execute()
    {
        Move();
        StateChange();
        //进入移动动画
        Debug.Log("Executing Move State");
    }
    public override void Exit()
    {
        Debug.Log("Exiting Move State");
        //取消特定的监听。
    }
    private void Move()
    {
        //实现移动
    }
    private void StateChange()
    {
	    if(_Input.Run == true)
	    {
		    StateMachine.ChangeState("Run");
	    }
    }
}
```